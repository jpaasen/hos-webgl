<html>
<header>
<title>Huygens' on Speed - WebGL/three.js</title>
<meta charset="utf-8">
<style>canvas {width: 100%; height: 100%}</style>
</header>

<body>
<script src="js/three.min.js"></script>
<script src="js/stats.min.js"></script>

<script type="x-shader/x-vertex" id='vertShader'>
	varying vec2 pixelPos;
	void main() {
		vec4 pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		gl_Position = pos;
		pixelPos = vec2(pos.x, pos.y);
	}
</script>

<script type="x-shader/x-fragment" id='fragShader'>
	varying vec2 pixelPos;
	uniform float time;
	uniform float observationAreaSize;
	uniform int nSrc;
	uniform float minDist;
	uniform float maxDist;

	uniform vec3 srcPos[100];
	uniform float srcTimestamps[100];

	void main() {

		float c = 1540.0;
		float f = 0.5e6;
		float pi = 3.14;

		float sinValue = 0.0;
		for (int i = 0; i < 100; ++i) {

			if (i < nSrc) {

				vec3 obs = vec3(pixelPos.x*observationAreaSize, pixelPos.y*observationAreaSize, 0.0);
				vec3 src = srcPos[i] * observationAreaSize;
		
				float dist = length(obs - src);
				float travelTime = dist / c;
		
				if ((travelTime + srcTimestamps[i]) < time) {

					if (dist < minDist) // Prevent high values close the src
						dist = 1.0;

					sinValue += sin(2.0 * pi * f * travelTime) / dist;
				}
			}
		}

		if (nSrc > 0) {
			sinValue /= float(nSrc);
			if (sinValue > 0.0) {
				sinValue = sinValue/2.0 + 0.5;
				// Scale so that minValue becomes black
				float minValue = 1.0 / maxDist;
				float maxValue = 1.0 / minDist;
				sinValue = ((maxValue / (maxValue - minValue)) * sinValue) - (minValue / (maxValue - minValue));

				// Debug values
				/*if (sinValue > 1.0)
					sinValue = 1.0;
				else if (sinValue < 0.0)
					sinValue = 0.5;
				else 
					sinValue = 0.0;*/
			}
		}

		gl_FragColor = vec4(sinValue, sinValue, sinValue, 1.0);
	}
</script>

<div id='mainFrame' onmousemove="mouse_move(event)" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)">
	
</div>

<script>

	var nSrc = 0;
	var srcPos = [];
	var srcTimestamps = [];

	for (i = 0; i < 100; ++i) {
		srcPos[srcPos.length] = new THREE.Vector3(0,0,0);
		srcTimestamps[srcTimestamps.length] = 0.0;
	}

	var mouseDown = false;
	var mouseMoved = false;

	var observationAreaSize = 0.1; // in meters 
	var minDist = 1e-5;
	var maxDist = 1.0 / Math.sqrt( Math.pow(observationAreaSize, 2.0) * 2.0 );

	var uniforms = {
		time: { type: 'f', value: 0.0 }, 
		observationAreaSize: { type: 'f', value: observationAreaSize },
		nSrc: { type: 'i', value: 0 },
		minDist: { type: 'f', value: minDist},
		maxDist: { type: 'f', value: maxDist},
		srcPos: { type: 'v3v', value: srcPos },
		srcTimestamps: {type: 'fv1', value: srcTimestamps }
	};

	var container = document.getElementById('mainFrame');

	var width = window.innerHeight / 2;
	var height = window.innerHeight / 2;

	var scene = new THREE.Scene(); 
	var camera = new THREE.OrthographicCamera(-width/2, width/2, -height/2, height/2, 1, 1000);
	var renderer = new THREE.WebGLRenderer(); 
	renderer.setSize( width, height ); 
	container.appendChild( renderer.domElement );

	var stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	container.appendChild( stats.domElement );

	var geometry = new THREE.BoxGeometry(width, height, 1);
	var vertShader = document.getElementById('vertShader').textContent;
	var fragShader = document.getElementById('fragShader').textContent;
	var material = new THREE.ShaderMaterial({uniforms: uniforms, vertexShader: vertShader, fragmentShader: fragShader});
	var cube = new THREE.Mesh( geometry, material );
	scene.add( cube );

	camera.position.z = 5;

	function reset(event) {
    	uniforms.time.value = 0.0;
	}

	function update_coords(event) {
		if (mouseDown) {
    		uniforms.srcPosX.value = (event.clientX / document.getElementById('mainFrame').offsetHeight - 0.5) *  2.0;
    		uniforms.srcPosY.value = (event.clientY / document.getElementById('mainFrame').offsetHeight - 0.5) *  2.0;
    	}
	}

	function addSrc(x, y) {
		if (nSrc <= 100) {
			var vec = new THREE.Vector3(
				(x / document.getElementById('mainFrame').offsetHeight - 0.5) *  2.0, 
				(y / document.getElementById('mainFrame').offsetHeight - 0.5) * -2.0, 0);
			srcPos[nSrc] = vec;
			srcTimestamps[nSrc] = uniforms.time.value;

			nSrc++;
	
			console.log(vec);
	
			uniforms.nSrc.value = nSrc;
			uniforms.srcPos.value = srcPos; // Not needed? Reference?
		}		
	}

	function mouse_down(event) {
		if (event.button == 0)
			mouseDown = true;
	}

	function mouse_up(event) {
		if (event.button == 0)
			if (mouseMoved) {
				mouseMoved = false;
			} else {
				addSrc(event.clientX, event.clientY);
			}
			mouseDown = false;
	}

	function mouse_move(event) {
		if (event.button == 0)
			if (mouseDown) {
				addSrc(event.clientX, event.clientY);
				mouseMoved = true;
			}
	}

	function render() {
		requestAnimationFrame(render);

		stats.update();

		uniforms.time.value += 5e-7;

		renderer.render(scene, camera);
	}
	render();
</script>

</body>

</html>
